---
# This play must include "localhost" in the list of hosts, and otherwise should
# be run one host at a time. That is, supply -l localhost,kube01.prod for one
# host at time.
# Based on:
# https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/

- hosts: localhost
  vars:
    version: 1.24.9
    pkg_version: 1.24.9-00
  tasks:
  - name: Assign kubernetes version
    set_fact:
      version: "{{ version }}"
      pkg_version: "{{ pkg_version }}"
    delegate_to: localhost

- hosts: kapi,kube
  become: yes
  become_user: root
  vars:
    # This will fail if localhost was not added to the play
    version: "{{ hostvars['localhost']['version'] }}"
    pkg_version: "{{ hostvars['localhost']['pkg_version'] }}"
  tasks:
  - name: Allow kubeadm upgrades
    dpkg_selections:
      name: "{{ item }}"
      selection: install
    with_items:
    - kubeadm
    - kubectl
    - kubelet

  - name: "Update kubeadm to {{ version }}"
    apt:
      name: "kubeadm={{ pkg_version }}"
      state: present
      # Uncomment for downgrade
      # force: true
      update_cache: yes
      force_apt_get: yes
      cache_valid_time: 86400  # one day

  - name: Check upgrade plan
    command: kubeadm upgrade plan
    when: root_node is defined and root_node == "true"
    register: upgrade_plan

  - debug:
      var: upgrade_plan.stdout_lines

- hosts: kapi
  become: yes
  become_user: root
  vars:
    version: "{{ hostvars['localhost']['version'] }}"
    pkg_version: "{{ hostvars['localhost']['pkg_version'] }}"
  vars_prompt:
  - name: confirm_upgrade
    prompt: "Upgrade to {{ version }}? Press return to continue, or ctrl-c to abort"
    private: false

- hosts: kapi,kube
  become: yes
  become_user: root
  serial: 1
  vars:
    version: "{{ hostvars['localhost']['version'] }}"
    pkg_version: "{{ hostvars['localhost']['pkg_version'] }}"
    kube_config: "{{ lookup('env','HOME') }}/.kube/{{ groups['kapi'][0] }}.config"
  tasks:
  - name: "Upgrade first node in the cluster to {{ version }}"
    command: "kubeadm upgrade apply {{ version }} --yes"
    when: root_node is defined and root_node == "true"
    register: upgrade_root

  - name: "Upgrade node to {{ version }}"
    command: "kubeadm upgrade node"
    when: (root_node is not defined or root_node == "false")
    register: upgrade_node

  - debug:
      var: upgrade_root.stdout_lines

  - debug:
      var: upgrade_node.stdout_lines

  - name: Drain node
    delegate_to: localhost
    command: "kubectl drain {{ ansible_hostname }} --ignore-daemonsets --kubeconfig={{ kube_config }} --delete-emptydir-data=true --force"

  - name: "Update kubernetes packages to {{ version }}"
    apt:
      name:
      - "kubeadm={{ pkg_version }}"
      - "kubectl={{ pkg_version }}"
      - "kubelet={{ pkg_version }}"
      state: present
      # Uncomment for downgrade
      # force: true
      update_cache: yes
      force_apt_get: yes
      cache_valid_time: 86400  # one day

  - name: Restart kubelet
    service:
      name: kubelet
      daemon_reload: yes
      state: restarted

  - name: Uncordon the node
    delegate_to: localhost
    command: "kubectl uncordon {{ ansible_hostname }} --kubeconfig={{ kube_config }}"

  - name: Verify status of the cluster
    command: "kubectl get nodes --kubeconfig={{ kube_config }}"
    register: get_nodes
    delegate_to: localhost

  - debug:
      var: get_nodes.stdout_lines

  - name: Prevent future accidental kubeadm upgrades
    dpkg_selections:
      name: "{{ item }}"
      selection: hold
    with_items:
    - kubeadm
    - kubectl
    - kubelet
